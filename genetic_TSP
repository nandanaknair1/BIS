import numpy as np
import random

# ----- Distance Calculation -----
def route_distance(route, dist_matrix):
    distance = 0
    for i in range(len(route)):
        distance += dist_matrix[route[i - 1], route[i]]
    return distance

# ----- Fitness -----
def fitness(route, dist_matrix):
    return 1 / route_distance(route, dist_matrix)

# ----- Create Initial Population -----
def initial_population(pop_size, num_cities):
    return [list(np.random.permutation(num_cities)) for _ in range(pop_size)]

# ----- Selection (Tournament) -----
def selection(population, dist_matrix, k=6):
    selected = random.sample(population, k)
    selected.sort(key=lambda r: route_distance(r, dist_matrix))
    return selected[0]

# ----- Crossover (Ordered Crossover) -----
def crossover(parent1, parent2):
    start, end = sorted(random.sample(range(len(parent1)), 2))
    child = [-1] * len(parent1)
    child[start:end] = parent1[start:end]

    fill_pos = end
    for city in parent2:
        if city not in child:
            if fill_pos >= len(parent1):
                fill_pos = 0
            child[fill_pos] = city
            fill_pos += 1
    return child

# ----- Mutation (Swap Cities) -----
def mutate(route, mutation_rate=0.1):
    route = route.copy()
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# ----- GA Main -----
def genetic_algorithm(dist_matrix, pop_size=50, generations=200, mutation_rate=0.1):
    num_cities = len(dist_matrix)
    population = initial_population(pop_size, num_cities)

    best_route = None
    best_distance = float("inf")

    for gen in range(generations):
        # Evaluate population
        population = sorted(population, key=lambda r: route_distance(r, dist_matrix))
        current_best = population[0]
        current_distance = route_distance(current_best, dist_matrix)

        if current_distance < best_distance:
            best_route = current_best
            best_distance = current_distance

        # Print progress every 10 generations
        if (gen + 1) % 10 == 0 or gen == generations - 1:
            print(f"Generation {gen+1}: Best Distance = {best_distance}")

        # Generate new population
        new_population = []
        for _ in range(pop_size):
            parent1 = selection(population, dist_matrix)
            parent2 = selection(population, dist_matrix)
            child = crossover(parent1, parent2)
            child = mutate(child, mutation_rate)
            new_population.append(child)
        population = new_population

    # Ensure final best route is returned as a full cycle (back to start)
    best_route_cycle = [int(city) for city in best_route] + [int(best_route[0])]
    return best_route_cycle, best_distance


# ----- Example Run -----
np.random.seed(51)
num_cities = 10
dist_matrix = np.random.randint(10, 100, size=(num_cities, num_cities))
dist_matrix = (dist_matrix + dist_matrix.T) // 2  # Symmetric
np.fill_diagonal(dist_matrix, 0)

best_route, best_distance = genetic_algorithm(dist_matrix, generations=200)

print("\nFinal Best Route:", best_route)
print("Final Best Distance:", best_distance)
