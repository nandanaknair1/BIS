import numpy as np
import random
import operator
import math

# ----- Function Set -----
FUNCTIONS = {
    "add": operator.add,
    "sub": operator.sub,
    "mul": operator.mul,
    "sin": math.sin,
    "cos": math.cos
}
TERMINALS = ["x"]

# ----- Random Expression Tree -----
def random_expression(depth=3):
    if depth == 0 or (depth > 1 and random.random() < 0.3):
        if random.random() < 0.5:
            return "x"
        else:
            return str(round(random.uniform(-3, 3), 2))
    func = random.choice(list(FUNCTIONS.keys()))
    if func in ["sin", "cos"]:
        return (func, random_expression(depth - 1))
    else:
        return (func, random_expression(depth - 1), random_expression(depth - 1))

# ----- Evaluate Expression -----
def evaluate(expr, x):
    if isinstance(expr, str):
        return x if expr == "x" else float(expr)
    if isinstance(expr, tuple):
        func = expr[0]
        if func in ["sin", "cos"]:
            return FUNCTIONS[func](evaluate(expr[1], x))
        else:
            return FUNCTIONS[func](evaluate(expr[1], x), evaluate(expr[2], x))

# ----- Fitness -----
def fitness(expr, X, y):
    preds = [evaluate(expr, xi) for xi in X]
    error = np.mean((np.array(preds) - y) ** 2)
    return error

# ----- Mutation -----
def mutate(expr):
    if random.random() < 0.2:
        return random_expression(depth=3)
    if isinstance(expr, tuple):
        if len(expr) == 2:  # unary
            return (expr[0], mutate(expr[1]))
        elif len(expr) == 3:  # binary
            return (expr[0], mutate(expr[1]), mutate(expr[2]))
    return expr


# ----- Crossover -----
def crossover(expr1, expr2):
    if random.random() < 0.5:
        return expr2  # swap whole subtree
    
    if isinstance(expr1, tuple) and isinstance(expr2, tuple):
        if len(expr1) == 2 and len(expr2) == 2:  # both unary
            return (expr1[0], crossover(expr1[1], expr2[1]))
        elif len(expr1) == 3 and len(expr2) == 3:  # both binary
            return (expr1[0],
                    crossover(expr1[1], expr2[1]),
                    crossover(expr1[2], expr2[2]))
    
    return expr1

# ----- Expression to Equation String -----
def expr_to_str(expr):
    if isinstance(expr, str) or isinstance(expr, (int, float)):
        return str(expr)
    
    op = expr[0]
    if op == 'add':
        return f"({expr_to_str(expr[1])} + {expr_to_str(expr[2])})"
    elif op == 'sub':
        return f"({expr_to_str(expr[1])} - {expr_to_str(expr[2])})"
    elif op == 'mul':
        return f"({expr_to_str(expr[1])} * {expr_to_str(expr[2])})"
    elif op == 'div':
        return f"({expr_to_str(expr[1])} / {expr_to_str(expr[2])})"
    else:
        return str(expr)

# ----- Genetic Algorithm -----
def symbolic_regression(X, y, pop_size=50, generations=50):
    population = [random_expression(depth=3) for _ in range(pop_size)]
    best_expr, best_fit = None, float("inf")

    for gen in range(generations):
        scored = [(expr, fitness(expr, X, y)) for expr in population]
        scored.sort(key=lambda x: x[1])

        if scored[0][1] < best_fit:
            best_expr, best_fit = scored[0]

        if gen % 10 == 0 or gen == generations - 1:
            print(f"Gen {gen+1} - Best Fitness: {best_fit}")

        new_pop = []
        for _ in range(pop_size):
            parent1, parent2 = random.choice(scored[:10])[0], random.choice(scored[:10])[0]
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_pop.append(child)
        population = new_pop

    return best_expr, best_fit

# ----- Example Run -----
X = np.linspace(-5, 5, 50)
y = X**2 + 2*X + 1  # Target function

best_expr, best_error = symbolic_regression(X, y, generations=50)
print("\nBest Expression Found:", expr_to_str(best_expr))

print("Error:", best_error)

