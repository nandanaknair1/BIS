import numpy as np
import random

def euclidean_distance(city1, city2):
    return np.linalg.norm(np.array(city1) - np.array(city2))

def create_distance_matrix(cities):
    n = len(cities)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                dist_matrix[i][j] = euclidean_distance(cities[i], cities[j])
    return dist_matrix

class ACO:
    def __init__(self, n_ants, n_iterations, alpha, beta, rho, q, cities):
        self.n_ants = n_ants
        self.n_iterations = n_iterations
        self.alpha = alpha
        self.beta = beta
        self.rho = rho
        self.q = q
        self.cities = cities
        self.n = len(cities)

        self.dist_matrix = create_distance_matrix(cities)
        self.pheromone = np.ones((self.n, self.n)) / self.n

        self.best_length = float("inf")
        self.best_solution = None

    def construct_solution(self):
        solutions, lengths = [], []
        for _ in range(self.n_ants):
            unvisited = list(range(self.n))
            start = random.choice(unvisited)
            tour = [start]
            unvisited.remove(start)

            while unvisited:
                current = tour[-1]
                pheromone = self.pheromone[current][unvisited] ** self.alpha
                heuristic = (1 / self.dist_matrix[current][unvisited]) ** self.beta
                prob = pheromone * heuristic
                prob = prob / prob.sum()
                next_city = np.random.choice(unvisited, p=prob)
                tour.append(next_city)
                unvisited.remove(next_city)

            solutions.append([int(city) for city in tour])
            lengths.append(self.calculate_tour_length(tour))
        return solutions, lengths

    def calculate_tour_length(self, tour):
        return sum(self.dist_matrix[tour[i]][tour[(i + 1) % self.n]] for i in range(len(tour)))

    def update_pheromones(self, solutions, lengths):
        self.pheromone *= (1 - self.rho)
        for tour, length in zip(solutions, lengths):
            for i in range(len(tour)):
                a, b = tour[i], tour[(i + 1) % self.n]
                self.pheromone[a][b] += self.q / length
                self.pheromone[b][a] += self.q / length

    def run(self):
        for _ in range(self.n_iterations):
            solutions, lengths = self.construct_solution()
            min_length = min(lengths)
            min_index = lengths.index(min_length)
            if min_length < self.best_length:
                self.best_length = min_length
                self.best_solution = solutions[min_index]
            self.update_pheromones(solutions, lengths)
        return self.best_solution, self.best_length

# -------------------------
# Example Usage
# -------------------------
if __name__ == "__main__":
    num_cities = 12
    cities = [(random.randint(0, 100), random.randint(0, 100)) for _ in range(num_cities)]

    aco = ACO(
        n_ants=30,
        n_iterations=200,
        alpha=1.0,
        beta=5.0,
        rho=0.3,
        q=100,
        cities=cities
    )

    best_solution, best_length = aco.run()

    print("Best Tour (city indices):", best_solution)
    print("Best Tour Length:", round(best_length, 2))

